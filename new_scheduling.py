###########################################################################
# Automated Finishing Process Scheduler: To improve the process rules and 
# scheduling logic for the two slitting machines to reduce bottlenecks and
# meet deadlines better. The output generated by input parameters will be 
# used as a reference guide for improved planning. 
# Authors: Arushi Agrawal, Heidi Shaffer, Mitali Shenoy, & Micah Wallis
# Date: 5/7/2022
# Course: CS 4485 Spring 2022
# Sponsor: Tetra Pak LLC
###########################################################################

from re import T
import pandas as pd
import tkinter as tk 
import datetime
import os

from tkinter import filedialog
from tkinter import *

# Open 2 intermediary output files for dumping standard output
file1 = open('output1.txt', 'w')
file2 = open('output2.txt', 'w')

roll_runtime = 18 # average processing time for one roll through the slitter machine
qsv_change_runtime = 40 # average overhead time for every QSV change to set up knife settings

# Defining a Node for each WIP order
class Node: 
    # Constructing a new node
    def __init__(self, orderID, noRolls, noLanes, qsv, waste, no_coprint, restriction, due_date): 
        
        self.orderID = orderID
        
        if noRolls > 7:
            self.isLarge = True #flags if a single large order
        else:
            self.isLarge = False
        if orderID[-1] == 'C':  #flags if order is a Coprint job
            self.isCoprint = True
        else:
            self.isCoprint = False
        
        self.noRolls = noRolls
        self.noLanes = noLanes
        self.qsv = qsv
        self.waste = waste
        self.no_coprint = no_coprint
        self.restriction = restriction
        self.due_date = due_date

        self.start_time = None
        self.end_time = None
        self.next = None 
        self.prev = None 

# Defining Doubly Linked list for each slitting machine
class doublyLinkedList: 
    # Constructing empty list
    def __init__(self): 
        self.head = None

    # Inserting a WIP order at the beginning of the list
    def insertAtBeg(self,new_node): 

        new_node.next = self.head
        new_node.prev = None 

        if self.head is not None: 
            self.head.prev = new_node

        self.head = new_node
        # Updating start and end time for remaining nodes following the 
        # newly added node in the list
        new_node.start_time = 0
        new_node.end_time = roll_runtime * new_node.noRolls
        last = self.head
        while (last.next is not None):
            last = last.next
            last.start_time = last.prev.end_time
            last.end_time = last.start_time + (roll_runtime * last.noRolls)


    # Inserting a WIP order in the middle of the list
    def insertAtPos(self, prev_node, new_node):
        if prev_node is None: 
            print("This node does not exist")
            return 

        new_node.next = prev_node.next
        prev_node.next = new_node
        new_node.prev = prev_node

        if new_node.next is not None: 
            new_node.next.prev = new_node
        
        # Updating start and end time for remaining nodes following the 
        # newly added node in the list
        new_node.start_time = new_node.prev.end_time
        new_node.end_time = new_node.start_time + (roll_runtime * new_node.noRolls)

        rest = new_node
        while (rest.next is not None):
            rest = rest.next
            rest.start_time = rest.prev.end_time
            rest.end_time = rest.start_time + (roll_runtime * rest.noRolls)
            

    # Inserting a WIP order at the end of the list
    def insertAtEnd(self, new_node): 
        last = self.head

        new_node.next = None

        if self.head is None: 
            new_node.prev = None 
            new_node.start_time = 0
            new_node.end_time = roll_runtime * new_node.noRolls            
            self.head = new_node
            return 

        while (last.next is not None): 
            last = last.next
        
        last.next = new_node 
        new_node.prev = last

        # Setting start and end time for the newly added node in the list
        if new_node.start_time is None:
            new_node.start_time = last.end_time
            new_node.end_time = new_node.start_time + (roll_runtime * new_node.noRolls)
        else:
            new_node.start_time = qsv_change_runtime + last.end_time
            new_node.end_time = new_node.start_time + (roll_runtime * new_node.noRolls)

    # Printing schedule for a slitting machine to standard output
    def printList(self, node):
 
        text = ""
        while node:
            
            text = text + "{},{},{},{},{},{},{},{}\n".format(node.orderID, node.qsv, node.noLanes, node.noRolls, node.waste, node.no_coprint, node.restriction, node.due_date)
            node = node.next

        return text
    
    # Returns size of schedule (# of WIP orders in the schedule)
    def findSize(self, node):
    
        res = 0
        while (node != None):
            res = res + 1
            node = node.next
        
        return res

    # NOT REQUIRED TO RUN PROGRAM (USED FOR TESTING PURPOSES ONLY)
    # Output new Linked List that is a copy of current Linked List with out altering it.
    def CopyList(self): 
        # create new LinkedList
        newLinkedList = doublyLinkedList()
        current = self.head
        #below is from stackoverflow : https://stackoverflow.com/questions/36491307/how-to-copy-linked-list-in-python
        while current is not None:
            newNode = Node(current.orderID, current.noRolls, current.noLanes, current.qsv, current.waste, current.no_coprint, current.restriction, current.due_date)
            newLinkedList.insertAtEnd(newNode)
            current = current.next
        return newLinkedList
    
    # Swapping 2 nodes (WIP orders) within a current slitting machine schedule
    def swap(self, old, new):
        
        tail = self.head
        
        while (tail.next is not None):
            tail = tail.next
       
        if old == self.head:
            new.next = self.head.next
            new.prev = None
            # Setting up start and end time for swapping out the node at the beginning of the list
            new.start_time = 0
            new.end_time = new.start_time + (roll_runtime * new.noRolls)
            self.head = new
            
        elif old == tail:
            new.next = None
            new.prev = tail.prev
            # Setting up start and end time for swapping out the node at the end of the list
            new.start_time = new.prev.end_time
            new.end_time = new.start_time + (roll_runtime * new.noRolls)
            tail.prev.next = new
        else:
            new.prev = old.prev
            new.next = old.next
            # Setting up start and end time for swapping out the node in the middle of the list
            new.start_time = new.prev.end_time
            new.end_time = new.start_time + (roll_runtime * new.noRolls)
            old.prev.next = new
            old.next.prev = new

        # Updating start and end time for remaining nodes following the 
        # newly swapped in node in the list
        cur = new
        while cur.next is not None:
            if cur.prev.qsv != cur.qsv:
                cur.start_time = cur.prev.end_time + qsv_change_runtime
            cur.end_time = cur.start_time + (roll_runtime * cur.noRolls)
            cur = cur.next

        old.next = None
        old.prev = None
        return old # returns old node to be reprocessed (after it's been swapped out) 
    
tk.Tk().withdraw() # prevents an empty tkinter window from appearing

#asking the user to select their input file
file_path = filedialog.askopenfilename(title = "Select WIP Report")

#converting input excel file into a dataframe 
wr_df = pd.read_excel(file_path) #read Wip Report File (wp)

tk.Tk().withdraw() # prevents an empty tkinter window from appearing

# asking the user to select their input file
file_path = filedialog.askopenfilename(title = "Select Slit Plan")


# converting input excel file into a dataframe 
sp_df = pd.read_excel(file_path) #read Slit Plan file

# cleaning up the input data file for WIP report 
wr_df = wr_df.iloc[3:-4,:]
wr_df.columns = wr_df.iloc[0]
wr_df = wr_df.drop(wr_df.index[0])
wr_df = pd.DataFrame(wr_df)
wr_df = wr_df[["Material"," Order", " QSV", " Lanes", " No Of Rolls", " Potential Waste Length", " POrder Due Date"]]

# Filtering to include WIPs that are in the warehouse after the lamination stage ('WIP Printing-Lamina')
wr_df = pd.DataFrame(wr_df[wr_df['Material']=='WIP Printing-Lamina'])
wr_df = wr_df.astype({" Order": str, " Lanes": int, " No Of Rolls": int}) #setting the datatype for columns
# Defining new columns to pull from Slit Plan
wr_df[" POrder Due Date"] = pd.to_datetime(wr_df[" POrder Due Date"])
wr_df["Restriction"] = None

# cleaning up the input data file for Slit Plan
sp_df = sp_df[[0, "Order number", "Package.Volume", "Package.Shape", "Lane Assignment", "Size", "Customer name"]]
sp_df = sp_df.astype({0 : int, "Order number": str, "Package.Volume": str, "Package.Shape": str, "Lane Assignment": str}) #setting the datatype for columns

# Finding matching IDs between WIP report and Slit plan for each WIP order
for index, row in wr_df.iterrows():
    matching_id = sp_df[sp_df['Order number']==row[' Order']]
    volume = matching_id.iloc[0,2]
    shape = matching_id.iloc[0,3]

    # Defining restrictions based on Tetra Pak rules for volume and shape
    if (volume == "250 ml") and (shape == "Edge"):
        wr_df.at[index, 'Restriction'] = '55'
    elif (volume == "250 ml") and (shape == "Base Leaf"):
        wr_df.at[index, 'Restriction'] = "55"
    elif (volume == "125 ml") and (shape == "Slim"): 
        wr_df.at[index, 'Restriction'] = "54"
    else: 
        wr_df.at[index, 'Restriction'] = "na"

    wr_df.at[index, ' POrder Due Date'] = row[" POrder Due Date"].date()
    
# Sorting all WIP orders by due date
sorted_wr_df = wr_df.sort_values(by = [" POrder Due Date"])

sorted_wr_df = sorted_wr_df.reset_index()
curr_date = sorted_wr_df.at[0,' POrder Due Date']
# Splitting the date range in the WIP report into N buckets based on 2 day gaps
buckets = [[]]
bucket_no = 0
for index, row in sorted_wr_df.iterrows():
    if row[' POrder Due Date'] == curr_date or row[' POrder Due Date'] == curr_date+ datetime.timedelta(days=1):
        buckets[bucket_no].append(row)
    else:
        bucket_no +=1
        buckets.append([])
        curr_date = row[' POrder Due Date']
        buckets[bucket_no].append(row)

# Sorting within each bucket by QSV
grouped_df = pd.DataFrame()
for bucket in buckets: 
    tmp_df = pd.DataFrame(bucket)
    tmp_df = tmp_df.sort_values(by = [" QSV"])
    grouped_df = pd.concat([grouped_df, tmp_df])

schedule54 = doublyLinkedList() # linked list maintaining schedule for slitter 54
schedule55 = doublyLinkedList() # linkedlist maintaining schedule for slitter 55

# setting up estimated run times (ERT) for restricted orders on each slitter machine
ERT_54 = 0
ERT_55 = 0

# grouping orders by restriction
df_54 = grouped_df[grouped_df['Restriction']=='54']
df_55 = grouped_df[grouped_df['Restriction']=='55']

# counting number of restricted rolls on each machine
t_rolls_54 = df_54[" No Of Rolls"].sum()
t_rolls_55 = df_55[" No Of Rolls"].sum()

# counting number of unique QSVs on each machine
t_qsv_54 = df_54[" QSV"].nunique()
t_qsv_55 = df_55[" QSV"].nunique()

# calcualting overhead time for each QSV change + processing time for each restricted order
ERT_54 = (t_rolls_54 *roll_runtime) + (t_qsv_55 *qsv_change_runtime)
ERT_55 = (t_rolls_55 *roll_runtime) + (t_qsv_55 *qsv_change_runtime)

# tracking the last QSV on each machine to detect QSV change
curr_qsv_54 = ""
curr_qsv_55 = ""

# creating a node from the both WIP Report and Slit Plan input files
def create_node(wip_row):

    orderID = wip_row[" Order"]
    noRolls = wip_row[" No Of Rolls"]
    noLanes = wip_row[" Lanes"]
    qsv = wip_row[" QSV"]
    waste = wip_row[" Potential Waste Length"]
    due_date = wip_row[" POrder Due Date"]

    # Flagging coprint job if last character in the orderID is a 'C'
    if orderID[-1]=='C':
        matching_id = sp_df[sp_df['Order number']==orderID]
        lane_id = int(matching_id.iloc[0,0])
        matching_rows = sp_df[sp_df[0]==lane_id]
        no_coprint = len(matching_rows)
        
    else:
        no_coprint = 0

    matching_id = sp_df[sp_df['Order number']==orderID]
    volume = matching_id.iloc[0,2]
    shape = matching_id.iloc[0,3]

    # Defining restrictions based on Tetra Pak rules for volume and shape
    if (volume == "250 ml") and (shape == "Edge"):
        restriction = "55"
    elif (volume == "250 ml") and (shape == "Base Leaf"):
        restriction = "55"
    elif (volume == "125 ml") and (shape == "Slim"): 
        restriction = "54"
    else: 
        restriction = "na"

    # new node is created with all the defined parameters 
    new_node = Node(orderID, noRolls, noLanes, qsv, waste, no_coprint, restriction, due_date)

    global ERT_54
    global ERT_55
    global curr_qsv_55
    global curr_qsv_54
    
    return new_node

# Given a new WIP order, scan through each machine to find the best spot to insert it
def scanToInsert(node):
    global curr_qsv_54
    global curr_qsv_55
    global ERT_55
    global ERT_54

    # when both schedules are empty and restrictions don't apply, schedule on either; else schedule on restricted machine
    if schedule54.head is None: 
        if schedule55.head is None:
            if node.restriction == '54' or node.restriction =='na':
                schedule54.insertAtEnd(node)
                curr_qsv_54 = node.qsv
                return
            elif node.restriction == '55':
                schedule55.insertAtEnd(node)
                curr_qsv_55 = node.qsv
                return

    # cur1 and cur2 = pointers to the end of the list
    cur1 = schedule54.head
    cur2 = schedule55.head
    if cur1 is not None:
        while (cur1.next is not None):
            cur1 = cur1.next
    if cur2 is not None:
        while (cur2.next is not None):
            cur2 = cur2.next
    # if only the list for slitter 54 is empty and there's no restriction, 
    # schedule order to empty list otherwise schedule on restricted list
    if schedule54.head is None: 
        if schedule55.head is not None:
            if cur2.qsv == node.qsv:
                schedule55.insertAtEnd(node)
                curr_qsv_55 = node.qsv
                return
            else:
                if node.restriction == '55':
                    schedule55.insertAtEnd(node)
                    curr_qsv_55 = node.qsv
                    return
                elif node.restriction == '54':
                    schedule54.insertAtEnd(node)
                    curr_qsv_54 = node.qsv
                    return
                else:
                    # If order is unrestricted, and the runtime on one schedule is lower than 
                    # the other, schedule order on machine with lesser ERT
                    if node.restriction == 'na' and ERT_54 < ERT_55:
                        if cur1 is not None:
                            # After adding unrestricted orders to a list, update estimated run times (ERT)
                            if cur1.qsv is not node.qsv:
                                ERT_54 += (qsv_change_runtime +roll_runtime*node.noRolls)
                            else:
                                ERT_54 += (roll_runtime*node.noRolls)
                        schedule54.insertAtEnd(node)
                        curr_qsv_54 = node.qsv
                        return
                    else:
                        if cur2 is not None:
                            if cur2.qsv is not node.qsv:
                                ERT_55 += (qsv_change_runtime +roll_runtime*node.noRolls)
                            else:
                                ERT_55 += (roll_runtime*node.noRolls)
                        schedule55.insertAtEnd(node)
                        curr_qsv_55 = node.qsv
                        return
    
    # if only the list for slitter 55 is empty and there's no restriction, 
    # schedule order to empty list otherwise schedule on restricted list
    elif schedule54.head is not None: 
        if schedule55.head is None:
            if cur1.qsv == node.qsv:
                schedule54.insertAtEnd(node)
                curr_qsv_54 = node.qsv
                return
            else:
                if node.restriction == '54':
                    schedule54.insertAtEnd(node)
                    curr_qsv_54 = node.qsv
                    return
                elif node.restriction =="55":
                    schedule55.insertAtEnd(node)
                    curr_qsv_55 = node.qsv
                    return
                else:
                    # If order is unrestricted, and the runtime on one schedule is lower than 
                    # the other, schedule order on machine with lesser ERT
                    if node.restriction == 'na' and ERT_54 < ERT_55:
                        if cur1 is not None:
                            # After adding unrestricted orders to a list, update estimated run times (ERT)
                            if cur1.qsv is not node.qsv:
                                ERT_54 += (qsv_change_runtime +roll_runtime*node.noRolls)
                            else:
                                ERT_54 += (roll_runtime*node.noRolls)
                        schedule54.insertAtEnd(node)
                        curr_qsv_54 = node.qsv
                        return
                    else:
                        if cur2 is not None:
                            if cur2.qsv is not node.qsv:
                                ERT_55 += (qsv_change_runtime +roll_runtime*node.noRolls)
                            else:
                                ERT_55 += (roll_runtime*node.noRolls)
                        schedule55.insertAtEnd(node)
                        curr_qsv_55 = node.qsv
                        return
 
    # If neither list is empty, and if the qsv of the current WIP does not match the QSV on the last order of either schedule,
    # find the schedule with fewer WIPs
    if (cur1.qsv != node.qsv) and (cur2.qsv != node.qsv):
        if schedule54.findSize(schedule54.head) < schedule55.findSize(schedule55.head):
            if node.restriction == "54":
                schedule54.insertAtEnd(node)
                curr_qsv_54 = node.qsv
                return
            elif node.restriction == '55': 
                schedule55.insertAtEnd(node)
                curr_qsv_55 = node.qsv
                return
            else:
                if node.restriction == 'na' and ERT_54 < ERT_55:
                    if cur1 is not None:
                        if cur1.qsv is not node.qsv:
                                ERT_54 += (qsv_change_runtime +roll_runtime*node.noRolls)
                        else:
                            ERT_54 += (roll_runtime*node.noRolls)
                    schedule54.insertAtEnd(node)
                    curr_qsv_54 = node.qsv
                    return
                else:
                    if cur1 is not None:
                        if cur2.qsv is not node.qsv:
                                ERT_55 += (qsv_change_runtime +roll_runtime*node.noRolls)
                        else:
                                ERT_55 += (roll_runtime*node.noRolls)
                    schedule55.insertAtEnd(node)
                    curr_qsv_55 = node.qsv
                    return
        # If neither list is empty and the QSV didn't change, then add to restricted list 
        # or if unrestricted add to list with smaller ERT
        else:
            if node.restriction == "55":
                schedule55.insertAtEnd(node)
                curr_qsv_55 = node.qsv
                return
            elif node.restriction == '54': 
                schedule54.insertAtEnd(node)
                curr_qsv_54 = node.qsv
                return
            else: 
                if node.restriction == 'na' and ERT_54 < ERT_55:
                    if cur1 is not None:
                        if cur1.qsv is not node.qsv:
                                ERT_54 += (qsv_change_runtime +roll_runtime*node.noRolls)
                        else:
                                ERT_54 += (roll_runtime*node.noRolls)
                    schedule54.insertAtEnd(node)
                    curr_qsv_54 = node.qsv
                    return
                else:
                    if cur1 is not None:
                        if cur2.qsv is not node.qsv:
                                ERT_55 += (qsv_change_runtime +roll_runtime*node.noRolls)
                        else:
                                ERT_55 += (roll_runtime*node.noRolls)
                    schedule55.insertAtEnd(node)
                    curr_qsv_55 = node.qsv
                    return

    # if neither list is empty, but current QSV matches the last order's QSV on either machine 
    # schedule then find the best spot to determine the best compatible location on the matching schedule
    if cur1.qsv == node.qsv:
        findBestSpot(node)
    else:
        findBestSpot(node)

# Compares the compatibility between rolls that are already scheduled vs. the new roll and determine if any improvement 
# can be made. If there is any improvement then the old roll will be swapped with the new one. If there is no improvement, 
# then the new roll will simply be added to the end.
def findBestSpot(node):
    global curr_qsv_54
    global curr_qsv_55
    global ERT_55
    global ERT_54
    cur1 = schedule54.head
    cur2 = schedule55.head
    
    best1 = None
    best2 = None

    while (cur1.next is not None):
        cur1 = cur1.next
    while (cur2.next is not None):
        cur2 = cur2.next
    
    best1 = cur1
    best2 = cur2
    bestImprovement = 0

    while (cur1 is not schedule54.head and cur1.qsv == node.qsv ):
        while (cur2 is not schedule55.head and cur2.end_time > cur1.start_time ):
            if cur2.start_time < cur1.end_time:
                if bestImprovement < isCompatible(cur2, node) - isCompatible(cur1, cur2):
                    bestImprovement = isCompatible(cur2, node) - isCompatible(cur1, cur2)
                    best1 = cur1
                    best2 = cur2            
            cur2 = cur2.prev
        cur1 = cur1.prev
    if bestImprovement <= 0:
        if node.restriction == "54":
            schedule54.insertAtEnd(node)
            curr_qsv_54 = node.qsv
            return
        elif node.restriction == "55": 
            schedule55.insertAtEnd(node)
            curr_qsv_55 = node.qsv
            return
        else: 
            if node.restriction == 'na' and ERT_54 < ERT_55:
                if cur1 is not None:
                    if cur1.qsv is not node.qsv:
                            ERT_54 += (qsv_change_runtime +18*node.noRolls)
                    else:
                            ERT_54 += (roll_runtime*node.noRolls)
                old = schedule54.swap(best1, node)
                schedule54.insertAtEnd(old)
                curr_qsv_54 = node.qsv
                return
            else:
                if cur1 is not None:
                    if cur2.qsv is not node.qsv:
                            ERT_55 += (qsv_change_runtime +roll_runtime*node.noRolls)
                    else:
                            ERT_55 += (roll_runtime*node.noRolls)
                old = schedule55.swap(best2, node)
                schedule55.insertAtEnd(old)
                curr_qsv_55 = node.qsv
                return
    else:
        if node.restriction == "54":
            old = schedule54.swap(best1, node) 
            schedule54.insertAtEnd(old)
            return
        elif node.restriction == "55": 
            old = schedule55.swap(best2, node) 
            schedule55.insertAtEnd(old)
            return
        else: 
            if node.restriction == 'na' and ERT_54 < ERT_55:
                if cur1 is not None:
                    if cur1.qsv is not node.qsv:
                            ERT_54 += (qsv_change_runtime +18*node.noRolls)
                    else:
                            ERT_54 += (roll_runtime*node.noRolls)
                old = schedule54.swap(best1, node)
                schedule54.insertAtEnd(old)
                curr_qsv_54 = node.qsv
                return
            else:
                if cur1 is not None:
                    if cur2.qsv is not node.qsv:
                            ERT_55 += (qsv_change_runtime +roll_runtime*node.noRolls)
                    else:
                            ERT_55 += (roll_runtime*node.noRolls)
                old = schedule55.swap(best2, node)
                schedule55.insertAtEnd(old)
                curr_qsv_55 = node.qsv
                return

# Takes two rolls and quantify their compatibility, which lets us compare and determine whether swapping 
# or inserting rolls adds any improvement.                
def isCompatible(node1, node2):
    # Increment compatibility score every time efficiency is detected, and decrememnt compatibility 
    # score everytime conflicts in variables occur (based on Tetra Pak machine constraints and defined rules)
    compatibiltyScore = 0
    totalNoLanes = node1.noLanes + node2.noLanes
    if totalNoLanes > 16:
        compatibiltyScore -= 2
    elif totalNoLanes > 14 and totalNoLanes <= 16:
        compatibiltyScore -= 1
    elif totalNoLanes >= 12 and totalNoLanes <= 14:
        compatibiltyScore += 1
    else:
        compatibiltyScore += 2

    if node1.isCoprint is True and node2.isCoprint is True:
        if node1.no_coprint + node2.no_coprint >= 8:
            compatibiltyScore -= 2
        else:
            compatibiltyScore -= 1
    if ((node1.isCoprint is True and node2.isLarge is True) or (node2.isCoprint is True and node1.isLarge is True)):
        compatibiltyScore += 1

    totalWaste = node1.waste + node2.waste
    if totalWaste > 1500:
        compatibiltyScore -= 2
    elif totalWaste >= 500 and totalWaste <= 1500:
        compatibiltyScore -= 1
    elif totalWaste < 500:
        compatibiltyScore += 1

    return compatibiltyScore

# within each bucketed and sorted wip orders, create new nodes to be processed and 
# inserted to either schedule
for index, row in grouped_df.iterrows():
   new_node = create_node(row)
   scanToInsert(new_node)

# Print each schedule to standard out and redirect to output1.txt and output2.txt
print("orderID,qsv,noLanes,noRolls,waste,no_coprint,restriction,due_date", file=file1)
print(schedule54.printList(schedule54.head), file=file1)
print("orderID,qsv,noLanes,noRolls,waste,no_coprint,restriction,due_date", file=file2)
print(schedule55.printList(schedule55.head), file=file2)

# Close output1.txt file
file1.close()

# Convert output1.txt to a csv file and then to a data frame
df_54 = pd.read_csv("output1.txt", delimiter=",")
# Add new columns to the data frame
df_54["package size"] = None
df_54["approximate duration"] = None
df_54["customer"] = None
for index, rows in df_54.iterrows():
    matching_id = sp_df[sp_df['Order number']==rows['orderID']]
    volume = matching_id.iloc[0,2]
    shape = matching_id.iloc[0,3]
    customer = matching_id.iloc[0,6]
    # populate new columns from Slit Plan
    df_54.at[index, 'package size'] = str(volume)+"-"+str(shape)
    df_54.at[index, 'approximate duration'] = rows["noRolls"]*roll_runtime
    df_54.at[index, 'customer'] = customer

# Define order of columns for schedule54 sheet in schedules.xlsx
df_54 = df_54[["orderID", "customer","qsv", "package size", "noLanes", "noRolls", "approximate duration", "waste", "no_coprint", "restriction", "due_date"]]

# Print ERT at the end of schedule54 sheet in schedules.xlsx
total_dict = {"orderID":["","Estimated Total Run Time: ",""], 
            "package size": ["", ERT_54, ""]}
temp_df = pd.DataFrame(total_dict)
df_54 = pd.concat([df_54, temp_df], ignore_index = True)

# Close output2.txt file
file2.close()

# Convert output1.txt to a csv file and then to a data frame
df_55 = pd.read_csv("output2.txt", delimiter=",")
# Add new columns to the data frame
df_55["package size"] = None
df_55["approximate duration"] = None
df_55["customer"] = None
for index, rows in df_55.iterrows():
    matching_id = sp_df[sp_df['Order number']==rows['orderID']]
    volume = matching_id.iloc[0,2]
    shape = matching_id.iloc[0,3]
    customer = matching_id.iloc[0,6]
    # populate new columns from Slit Plan
    df_55.at[index, 'package size'] = str(volume)+"-"+str(shape)
    df_55.at[index, 'approximate duration'] = rows["noRolls"]*roll_runtime
    df_55.at[index, 'customer'] = customer

# Define order of columns for schedule55 sheet in schedules.xlsx
df_55 = df_55[["orderID", "customer", "qsv", "package size", "noLanes", "noRolls", "approximate duration", "waste", "no_coprint", "restriction", "due_date"]]

# Print ERT at the end of schedule55 sheet in schedules.xlsx
total_dict = {"orderID":["","Estimated Total Run Time: ",""], 
            "package size": ["", ERT_55,""]}
temp_df = pd.DataFrame(total_dict)
df_55 = pd.concat([df_55, temp_df], ignore_index = True)

# Open file explorer to select where to put schedules.xlsx
root = Tk()
root.withdraw()
folder_selected = filedialog.askdirectory(title = "Select Output Folder")
print(folder_selected)
output_filename = folder_selected+"/schedules.xlsx"

# Open a new excel workbook with 2 sheets: schedule54 and schedule55
writer = pd.ExcelWriter(output_filename, engine='xlsxwriter')
df_54.to_excel(writer, sheet_name='Schedule 54', index = False)
df_55.to_excel(writer, sheet_name='Schedule 55', index = False)

# Combine both schedules into a single dataframe
tmp_54 = df_54
tmp_54["Scheduled Machine"] = 54
tmp_54.drop(tmp_54.tail(3).index,inplace=True)
total_dict = {"orderID":["","Estimated Total Run Time: ",""], 
            "package size": ["", ERT_54,""]}
temp_df = pd.DataFrame(total_dict)
tmp_54 = pd.concat([tmp_54, temp_df], ignore_index = True)

tmp_55 = df_55
tmp_55["Scheduled Machine"] = 55
tmp_55.drop(tmp_55.tail(3).index,inplace=True)
total_dict = {"orderID":["","Estimated Total Run Time: ",""], 
            "package size": ["", ERT_55,""]}
temp_df = pd.DataFrame(total_dict)
tmp_55 = pd.concat([tmp_55, temp_df], ignore_index = True)

blank= {"":[""]}
tmp_blank = pd.DataFrame(blank)
frames = [tmp_54, tmp_blank, tmp_55]
df_combined = pd.concat(frames, axis=1)

# Add combined schedule in a new sheet in the schedules.xlsx workbook
df_combined.to_excel(writer, sheet_name='Combined Schedules', index = False)

# Remove intermediary output files (output1.txt & output2.txt)
os.remove('output1.txt')
os.remove('output2.txt')

# Print ERTs of both slitters to console log
print("Generated slitter schedules in file 'schedules.xlsx'")
print( "Estimated Run Time on Slitter 54:", ERT_54, "minutes")
print( "Estimated Run Time on Slitter 55:", ERT_55, "minutes")

# Save schedules.xlsx & end of program
writer.save()
